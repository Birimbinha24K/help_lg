import {
  NOOP,
  mergeProps,
  useEventCallback,
  useFormContext,
  useRefWithInit,
  useRenderElement
} from "./chunk-4G6POLGN.js";
import {
  require_react_dom
} from "./chunk-VPTIPXRI.js";
import {
  require_jsx_runtime
} from "./chunk-3JXUIMPU.js";
import {
  require_react
} from "./chunk-4UQS7KPA.js";
import {
  __export,
  __publicField,
  __toESM
} from "./chunk-2GTGKKMZ.js";

// node_modules/@base-ui-components/react/esm/field/index.parts.js
var index_parts_exports = {};
__export(index_parts_exports, {
  Control: () => FieldControl,
  Description: () => FieldDescription,
  Error: () => FieldError,
  Label: () => FieldLabel,
  Root: () => FieldRoot,
  Validity: () => FieldValidity
});

// node_modules/@base-ui-components/react/esm/field/root/FieldRoot.js
var React3 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/react/esm/field/root/FieldRootContext.js
var React = __toESM(require_react(), 1);

// node_modules/@base-ui-components/react/esm/field/control/FieldControlDataAttributes.js
var FieldControlDataAttributes = function(FieldControlDataAttributes2) {
  FieldControlDataAttributes2["disabled"] = "data-disabled";
  FieldControlDataAttributes2["valid"] = "data-valid";
  FieldControlDataAttributes2["invalid"] = "data-invalid";
  FieldControlDataAttributes2["touched"] = "data-touched";
  FieldControlDataAttributes2["dirty"] = "data-dirty";
  FieldControlDataAttributes2["filled"] = "data-filled";
  FieldControlDataAttributes2["focused"] = "data-focused";
  return FieldControlDataAttributes2;
}({});

// node_modules/@base-ui-components/react/esm/field/utils/constants.js
var DEFAULT_VALIDITY_STATE = {
  badInput: false,
  customError: false,
  patternMismatch: false,
  rangeOverflow: false,
  rangeUnderflow: false,
  stepMismatch: false,
  tooLong: false,
  tooShort: false,
  typeMismatch: false,
  valid: null,
  valueMissing: false
};
var fieldValidityMapping = {
  valid(value) {
    if (value === null) {
      return null;
    }
    if (value) {
      return {
        [FieldControlDataAttributes.valid]: ""
      };
    }
    return {
      [FieldControlDataAttributes.invalid]: ""
    };
  }
};

// node_modules/@base-ui-components/react/esm/field/root/FieldRootContext.js
var FieldRootContext = React.createContext({
  invalid: void 0,
  controlId: void 0,
  setControlId: NOOP,
  labelId: void 0,
  setLabelId: NOOP,
  messageIds: [],
  setMessageIds: NOOP,
  name: void 0,
  validityData: {
    state: DEFAULT_VALIDITY_STATE,
    errors: [],
    error: "",
    value: "",
    initialValue: null
  },
  setValidityData: NOOP,
  disabled: void 0,
  touched: false,
  setTouched: NOOP,
  dirty: false,
  setDirty: NOOP,
  filled: false,
  setFilled: NOOP,
  focused: false,
  setFocused: NOOP,
  validate: () => null,
  validationMode: "onBlur",
  validationDebounceTime: 0,
  state: {
    disabled: false,
    valid: null,
    touched: false,
    dirty: false,
    filled: false,
    focused: false
  },
  markedDirtyRef: {
    current: false
  }
});
if (true)
  FieldRootContext.displayName = "FieldRootContext";
function useFieldRootContext(optional = true) {
  const context = React.useContext(FieldRootContext);
  if (context.setControlId === NOOP && !optional) {
    throw new Error("Base UI: FieldRootContext is missing. Field parts must be placed within <Field.Root>.");
  }
  return context;
}

// node_modules/@base-ui-components/react/esm/fieldset/root/FieldsetRootContext.js
var React2 = __toESM(require_react(), 1);
var FieldsetRootContext = React2.createContext({
  legendId: void 0,
  setLegendId: () => {
  },
  disabled: void 0
});
if (true)
  FieldsetRootContext.displayName = "FieldsetRootContext";
function useFieldsetRootContext() {
  return React2.useContext(FieldsetRootContext);
}

// node_modules/@base-ui-components/react/esm/field/root/FieldRoot.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var FieldRoot = React3.forwardRef(function FieldRoot2(componentProps, forwardedRef) {
  const {
    render,
    className,
    validate: validateProp,
    validationDebounceTime = 0,
    validationMode = "onBlur",
    name,
    disabled: disabledProp = false,
    invalid: invalidProp,
    ...elementProps
  } = componentProps;
  const {
    disabled: disabledFieldset
  } = useFieldsetRootContext();
  const {
    errors
  } = useFormContext();
  const validate = useEventCallback(validateProp || (() => null));
  const disabled = disabledFieldset || disabledProp;
  const [controlId, setControlId] = React3.useState(void 0);
  const [labelId, setLabelId] = React3.useState(void 0);
  const [messageIds, setMessageIds] = React3.useState([]);
  const [touched, setTouched] = React3.useState(false);
  const [dirty, setDirtyUnwrapped] = React3.useState(false);
  const [filled, setFilled] = React3.useState(false);
  const [focused, setFocused] = React3.useState(false);
  const markedDirtyRef = React3.useRef(false);
  const setDirty = React3.useCallback((value) => {
    if (value) {
      markedDirtyRef.current = true;
    }
    setDirtyUnwrapped(value);
  }, []);
  const invalid = Boolean(invalidProp || name && {}.hasOwnProperty.call(errors, name) && errors[name] !== void 0);
  const [validityData, setValidityData] = React3.useState({
    state: DEFAULT_VALIDITY_STATE,
    error: "",
    errors: [],
    value: null,
    initialValue: null
  });
  const valid = !invalid && validityData.state.valid;
  const state = React3.useMemo(() => ({
    disabled,
    touched,
    dirty,
    valid,
    filled,
    focused
  }), [disabled, touched, dirty, valid, filled, focused]);
  const contextValue = React3.useMemo(() => ({
    invalid,
    controlId,
    setControlId,
    labelId,
    setLabelId,
    messageIds,
    setMessageIds,
    name,
    validityData,
    setValidityData,
    disabled,
    touched,
    setTouched,
    dirty,
    setDirty,
    filled,
    setFilled,
    focused,
    setFocused,
    validate,
    validationMode,
    validationDebounceTime,
    state,
    markedDirtyRef
  }), [invalid, controlId, labelId, messageIds, name, validityData, disabled, touched, dirty, setDirty, filled, setFilled, focused, setFocused, validate, validationMode, validationDebounceTime, state]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    state,
    props: elementProps,
    customStyleHookMapping: fieldValidityMapping
  });
  return (0, import_jsx_runtime.jsx)(FieldRootContext.Provider, {
    value: contextValue,
    children: element
  });
});
if (true)
  FieldRoot.displayName = "FieldRoot";

// node_modules/@base-ui-components/react/esm/field/label/FieldLabel.js
var React7 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/utils/esm/useIsoLayoutEffect.js
var React4 = __toESM(require_react());
var noop = () => {
};
var useIsoLayoutEffect = typeof document !== "undefined" ? React4.useLayoutEffect : noop;

// node_modules/@base-ui-components/utils/esm/detectBrowser.js
var hasNavigator = typeof navigator !== "undefined";
var nav = getNavigatorData();
var platform = getPlatform();
var userAgent = getUserAgent();
var isWebKit = typeof CSS === "undefined" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter:none");
var isIOS = (
  // iPads can claim to be MacIntel
  nav.platform === "MacIntel" && nav.maxTouchPoints > 1 ? true : /iP(hone|ad|od)|iOS/.test(nav.platform)
);
var isFirefox = hasNavigator && /firefox/i.test(userAgent);
var isSafari = hasNavigator && /apple/i.test(navigator.vendor);
var isAndroid = hasNavigator && /android/i.test(platform) || /android/i.test(userAgent);
var isMac = hasNavigator && platform.toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
var isJSDOM = userAgent.includes("jsdom/");
function getNavigatorData() {
  if (!hasNavigator) {
    return {
      platform: "",
      maxTouchPoints: -1
    };
  }
  const uaData = navigator.userAgentData;
  if (uaData == null ? void 0 : uaData.platform) {
    return {
      platform: uaData.platform,
      maxTouchPoints: navigator.maxTouchPoints
    };
  }
  return {
    platform: navigator.platform ?? "",
    maxTouchPoints: navigator.maxTouchPoints ?? -1
  };
}
function getUserAgent() {
  if (!hasNavigator) {
    return "";
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map(({
      brand,
      version
    }) => `${brand}/${version}`).join(" ");
  }
  return navigator.userAgent;
}
function getPlatform() {
  if (!hasNavigator) {
    return "";
  }
  const uaData = navigator.userAgentData;
  if (uaData == null ? void 0 : uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform ?? "";
}

// node_modules/@base-ui-components/react/esm/floating-ui-react/utils/element.js
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@base-ui-components/utils/esm/useId.js
var React6 = __toESM(require_react());

// node_modules/@base-ui-components/utils/esm/safeReact.js
var React5 = __toESM(require_react(), 1);
var SafeReact = {
  ...React5
};

// node_modules/@base-ui-components/utils/esm/useId.js
var globalId = 0;
function useGlobalId(idOverride, prefix = "mui") {
  const [defaultId, setDefaultId] = React6.useState(idOverride);
  const id = idOverride || defaultId;
  React6.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`${prefix}-${globalId}`);
    }
  }, [defaultId, prefix]);
  return id;
}
var maybeReactUseId = SafeReact.useId;
function useId(idOverride, prefix) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride ?? (prefix ? `${prefix}-${reactId}` : reactId);
  }
  return useGlobalId(idOverride, prefix);
}

// node_modules/@base-ui-components/react/esm/utils/useBaseUiId.js
function useBaseUiId(idOverride) {
  return useId(idOverride, "base-ui");
}

// node_modules/@base-ui-components/react/esm/field/label/FieldLabel.js
var FieldLabel = React7.forwardRef(function FieldLabel2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    ...elementProps
  } = componentProps;
  const {
    labelId,
    setLabelId,
    state,
    controlId
  } = useFieldRootContext(false);
  const id = useBaseUiId(idProp);
  const htmlFor = controlId ?? void 0;
  useIsoLayoutEffect(() => {
    if (controlId != null || idProp) {
      setLabelId(id);
    }
    return () => {
      setLabelId(void 0);
    };
  }, [controlId, id, idProp, setLabelId]);
  const element = useRenderElement("label", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      id: labelId,
      htmlFor,
      onMouseDown(event) {
        const target = getTarget(event.nativeEvent);
        if (target == null ? void 0 : target.closest("button,input,select,textarea")) {
          return;
        }
        if (!event.defaultPrevented && event.detail > 1) {
          event.preventDefault();
        }
      }
    }, elementProps],
    customStyleHookMapping: fieldValidityMapping
  });
  return element;
});
if (true)
  FieldLabel.displayName = "FieldLabel";

// node_modules/@base-ui-components/react/esm/field/error/FieldError.js
var React8 = __toESM(require_react(), 1);
var FieldError = React8.forwardRef(function FieldError2(componentProps, forwardedRef) {
  const {
    render,
    id: idProp,
    className,
    match,
    ...elementProps
  } = componentProps;
  const id = useBaseUiId(idProp);
  const {
    validityData,
    state,
    name,
    setMessageIds
  } = useFieldRootContext(false);
  const {
    errors
  } = useFormContext();
  const formError = name ? errors[name] : null;
  let rendered = false;
  if (formError || match === true) {
    rendered = true;
  } else if (match) {
    rendered = Boolean(validityData.state[match]);
  } else {
    rendered = validityData.state.valid === false;
  }
  useIsoLayoutEffect(() => {
    if (!rendered || !id) {
      return void 0;
    }
    setMessageIds((v) => v.concat(id));
    return () => {
      setMessageIds((v) => v.filter((item) => item !== id));
    };
  }, [rendered, id, setMessageIds]);
  const element = useRenderElement("div", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      id,
      children: formError || (validityData.errors.length > 1 ? React8.createElement("ul", {}, validityData.errors.map((message) => React8.createElement("li", {
        key: message
      }, message))) : validityData.error)
    }, elementProps],
    customStyleHookMapping: fieldValidityMapping
  });
  if (!rendered) {
    return null;
  }
  return element;
});
if (true)
  FieldError.displayName = "FieldError";

// node_modules/@base-ui-components/react/esm/field/description/FieldDescription.js
var React9 = __toESM(require_react(), 1);
var FieldDescription = React9.forwardRef(function FieldDescription2(componentProps, forwardedRef) {
  const {
    render,
    id: idProp,
    className,
    ...elementProps
  } = componentProps;
  const {
    state
  } = useFieldRootContext(false);
  const id = useBaseUiId(idProp);
  const {
    setMessageIds
  } = useFieldRootContext();
  useIsoLayoutEffect(() => {
    if (!id) {
      return void 0;
    }
    setMessageIds((v) => v.concat(id));
    return () => {
      setMessageIds((v) => v.filter((item) => item !== id));
    };
  }, [id, setMessageIds]);
  const element = useRenderElement("p", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      id
    }, elementProps],
    customStyleHookMapping: fieldValidityMapping
  });
  return element;
});
if (true)
  FieldDescription.displayName = "FieldDescription";

// node_modules/@base-ui-components/react/esm/field/control/FieldControl.js
var React13 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/utils/esm/useControlled.js
var React10 = __toESM(require_react());
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = React10.useRef(controlled !== void 0);
  const [valueState, setValue] = React10.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  if (true) {
    React10.useEffect(() => {
      if (isControlled !== (controlled !== void 0)) {
        console.error([`Base UI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${name} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join("\n"));
      }
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = React10.useRef(defaultProp);
    React10.useEffect(() => {
      if (!isControlled && JSON.stringify(defaultValue) !== JSON.stringify(defaultProp)) {
        console.error([`Base UI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. To suppress this warning opt to use a controlled ${name}.`].join("\n"));
      }
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = React10.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}

// node_modules/@base-ui-components/react/esm/field/useField.js
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@base-ui-components/utils/esm/useLatestRef.js
function useLatestRef(value) {
  const latest = useRefWithInit(createLatestRef, value).current;
  latest.next = value;
  useIsoLayoutEffect(latest.effect);
  return latest;
}
function createLatestRef(value) {
  const latest = {
    current: value,
    next: value,
    effect: () => {
      latest.current = latest.next;
    }
  };
  return latest;
}

// node_modules/@base-ui-components/react/esm/field/utils/getCombinedFieldValidityData.js
function getCombinedFieldValidityData(validityData, invalid) {
  return {
    ...validityData,
    state: {
      ...validityData.state,
      valid: !invalid && validityData.state.valid
    }
  };
}

// node_modules/@base-ui-components/react/esm/field/useField.js
function useField(params) {
  const {
    formRef
  } = useFormContext();
  const {
    invalid,
    markedDirtyRef,
    validityData,
    setValidityData
  } = useFieldRootContext();
  const {
    enabled = true,
    value,
    id,
    name,
    controlRef,
    commitValidation
  } = params;
  const getValueRef = useLatestRef(params.getValue);
  useIsoLayoutEffect(() => {
    var _a;
    if (!enabled) {
      return;
    }
    let initialValue = value;
    if (initialValue === void 0) {
      initialValue = (_a = getValueRef.current) == null ? void 0 : _a.call(getValueRef);
    }
    if (validityData.initialValue === null && initialValue !== validityData.initialValue) {
      setValidityData((prev) => ({
        ...prev,
        initialValue
      }));
    }
  }, [enabled, setValidityData, value, validityData.initialValue, getValueRef]);
  useIsoLayoutEffect(() => {
    if (!enabled) {
      return;
    }
    if (id) {
      formRef.current.fields.set(id, {
        controlRef,
        validityData: getCombinedFieldValidityData(validityData, invalid),
        validate() {
          var _a;
          let nextValue = value;
          if (nextValue === void 0) {
            nextValue = (_a = getValueRef.current) == null ? void 0 : _a.call(getValueRef);
          }
          markedDirtyRef.current = true;
          ReactDOM.flushSync(() => commitValidation(nextValue));
        },
        getValueRef,
        name
      });
    }
  }, [commitValidation, controlRef, enabled, formRef, getValueRef, id, invalid, markedDirtyRef, name, validityData, value]);
  useIsoLayoutEffect(() => {
    const fields = formRef.current.fields;
    return () => {
      if (id) {
        fields.delete(id);
      }
    };
  }, [formRef, id]);
}

// node_modules/@base-ui-components/react/esm/field/control/useFieldControlValidation.js
var React12 = __toESM(require_react(), 1);

// node_modules/@base-ui-components/utils/esm/useOnMount.js
var React11 = __toESM(require_react(), 1);
var EMPTY = [];
function useOnMount(fn) {
  React11.useEffect(fn, EMPTY);
}

// node_modules/@base-ui-components/utils/esm/useTimeout.js
var EMPTY2 = 0;
var Timeout = class _Timeout {
  constructor() {
    __publicField(this, "currentId", (() => EMPTY2)());
    __publicField(this, "clear", () => {
      if (this.currentId !== EMPTY2) {
        clearTimeout(this.currentId);
        this.currentId = EMPTY2;
      }
    });
    __publicField(this, "disposeEffect", () => {
      return this.clear;
    });
  }
  static create() {
    return new _Timeout();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(delay, fn) {
    this.clear();
    this.currentId = setTimeout(() => {
      this.currentId = EMPTY2;
      fn();
    }, delay);
  }
  isStarted() {
    return this.currentId !== EMPTY2;
  }
};
function useTimeout() {
  const timeout = useRefWithInit(Timeout.create).current;
  useOnMount(timeout.disposeEffect);
  return timeout;
}

// node_modules/@base-ui-components/react/esm/field/control/useFieldControlValidation.js
var validityKeys = Object.keys(DEFAULT_VALIDITY_STATE);
function isOnlyValueMissing(state) {
  if (!state || state.valid || !state.valueMissing) {
    return false;
  }
  let onlyValueMissing = false;
  for (const key of validityKeys) {
    if (key === "valid") {
      continue;
    }
    if (key === "valueMissing") {
      onlyValueMissing = state[key];
    }
    if (state[key]) {
      onlyValueMissing = false;
    }
  }
  return onlyValueMissing;
}
function useFieldControlValidation() {
  const {
    setValidityData,
    validate,
    messageIds,
    validityData,
    validationMode,
    validationDebounceTime,
    invalid,
    markedDirtyRef,
    controlId,
    state,
    name
  } = useFieldRootContext();
  const {
    formRef,
    clearErrors
  } = useFormContext();
  const timeout = useTimeout();
  const inputRef = React12.useRef(null);
  const commitValidation = useEventCallback(async (value, revalidate = false) => {
    const element = inputRef.current;
    if (!element) {
      return;
    }
    if (revalidate) {
      if (state.valid !== false) {
        return;
      }
      const currentNativeValidity = element.validity;
      if (!currentNativeValidity.valueMissing) {
        const nextValidityData2 = {
          value,
          state: {
            ...DEFAULT_VALIDITY_STATE,
            valid: true
          },
          error: "",
          errors: [],
          initialValue: validityData.initialValue
        };
        element.setCustomValidity("");
        if (controlId) {
          const currentFieldData = formRef.current.fields.get(controlId);
          if (currentFieldData) {
            formRef.current.fields.set(controlId, {
              ...currentFieldData,
              ...getCombinedFieldValidityData(nextValidityData2, false)
              // invalid = false
            });
          }
        }
        setValidityData(nextValidityData2);
        return;
      }
      const currentNativeValidityObject = validityKeys.reduce((acc, key) => {
        acc[key] = currentNativeValidity[key];
        return acc;
      }, {});
      if (!currentNativeValidityObject.valid && !isOnlyValueMissing(currentNativeValidityObject)) {
        return;
      }
    }
    function getState(el) {
      const computedState = validityKeys.reduce((acc, key) => {
        acc[key] = el.validity[key];
        return acc;
      }, {});
      let hasOnlyValueMissingError = false;
      for (const key of validityKeys) {
        if (key === "valid") {
          continue;
        }
        if (key === "valueMissing" && computedState[key]) {
          hasOnlyValueMissingError = true;
        } else if (computedState[key]) {
          return computedState;
        }
      }
      if (hasOnlyValueMissingError && !markedDirtyRef.current) {
        computedState.valid = true;
        computedState.valueMissing = false;
      }
      return computedState;
    }
    timeout.clear();
    let result = null;
    let validationErrors = [];
    const nextState = getState(element);
    let defaultValidationMessage;
    if (element.validationMessage) {
      defaultValidationMessage = element.validationMessage;
      validationErrors = [element.validationMessage];
    } else {
      const formValues = Array.from(formRef.current.fields.values()).reduce((acc, field) => {
        var _a, _b;
        if (field.name && field.getValueRef) {
          acc[field.name] = (_b = (_a = field.getValueRef).current) == null ? void 0 : _b.call(_a);
        }
        return acc;
      }, {});
      const resultOrPromise = validate(value, formValues);
      if (typeof resultOrPromise === "object" && resultOrPromise !== null && "then" in resultOrPromise) {
        result = await resultOrPromise;
      } else {
        result = resultOrPromise;
      }
      if (result !== null) {
        nextState.valid = false;
        nextState.customError = true;
        if (Array.isArray(result)) {
          validationErrors = result;
          element.setCustomValidity(result.join("\n"));
        } else if (result) {
          validationErrors = [result];
          element.setCustomValidity(result);
        }
      }
    }
    const nextValidityData = {
      value,
      state: nextState,
      error: defaultValidationMessage ?? (Array.isArray(result) ? result[0] : result ?? ""),
      errors: validationErrors,
      initialValue: validityData.initialValue
    };
    if (controlId) {
      const currentFieldData = formRef.current.fields.get(controlId);
      if (currentFieldData) {
        formRef.current.fields.set(controlId, {
          ...currentFieldData,
          ...getCombinedFieldValidityData(nextValidityData, invalid)
        });
      }
    }
    setValidityData(nextValidityData);
  });
  const getValidationProps = React12.useCallback((externalProps = {}) => mergeProps({
    ...messageIds.length && {
      "aria-describedby": messageIds.join(" ")
    },
    ...state.valid === false && {
      "aria-invalid": true
    }
  }, externalProps), [messageIds, state.valid]);
  const getInputValidationProps = React12.useCallback((externalProps = {}) => mergeProps({
    onChange(event) {
      if (event.nativeEvent.defaultPrevented) {
        return;
      }
      clearErrors(name);
      if (validationMode !== "onChange") {
        commitValidation(event.currentTarget.value, true);
        return;
      }
      if (invalid) {
        return;
      }
      const element = event.currentTarget;
      if (element.value === "") {
        commitValidation(element.value);
        return;
      }
      timeout.clear();
      if (validationDebounceTime) {
        timeout.start(validationDebounceTime, () => {
          commitValidation(element.value);
        });
      } else {
        commitValidation(element.value);
      }
    }
  }, getValidationProps(externalProps)), [getValidationProps, clearErrors, name, timeout, commitValidation, invalid, validationMode, validationDebounceTime]);
  return React12.useMemo(() => ({
    getValidationProps,
    getInputValidationProps,
    inputRef,
    commitValidation
  }), [getValidationProps, getInputValidationProps, commitValidation]);
}

// node_modules/@base-ui-components/react/esm/utils/createBaseUIEventDetails.js
function createBaseUIEventDetails(reason, event) {
  let canceled = false;
  let allowPropagation = false;
  return {
    reason,
    event: event ?? new Event("base-ui"),
    cancel() {
      canceled = true;
    },
    allowPropagation() {
      allowPropagation = true;
    },
    get isCanceled() {
      return canceled;
    },
    get isPropagationAllowed() {
      return allowPropagation;
    }
  };
}

// node_modules/@base-ui-components/react/esm/field/control/FieldControl.js
var FieldControl = React13.forwardRef(function FieldControl2(componentProps, forwardedRef) {
  const {
    render,
    className,
    id: idProp,
    name: nameProp,
    value: valueProp,
    disabled: disabledProp = false,
    onValueChange,
    defaultValue,
    ...elementProps
  } = componentProps;
  const {
    state: fieldState,
    name: fieldName,
    disabled: fieldDisabled
  } = useFieldRootContext();
  const disabled = fieldDisabled || disabledProp;
  const name = fieldName ?? nameProp;
  const state = React13.useMemo(() => ({
    ...fieldState,
    disabled
  }), [fieldState, disabled]);
  const {
    setControlId,
    labelId,
    setTouched,
    setDirty,
    validityData,
    setFocused,
    setFilled,
    validationMode
  } = useFieldRootContext();
  const {
    getValidationProps,
    getInputValidationProps,
    commitValidation,
    inputRef
  } = useFieldControlValidation();
  const id = useBaseUiId(idProp);
  useIsoLayoutEffect(() => {
    setControlId(id);
    return () => {
      setControlId(void 0);
    };
  }, [id, setControlId]);
  useIsoLayoutEffect(() => {
    var _a;
    const hasExternalValue = valueProp != null;
    if (((_a = inputRef.current) == null ? void 0 : _a.value) || hasExternalValue && valueProp !== "") {
      setFilled(true);
    } else if (hasExternalValue && valueProp === "") {
      setFilled(false);
    }
  }, [inputRef, setFilled, valueProp]);
  const [value, setValueUnwrapped] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "FieldControl",
    state: "value"
  });
  const isControlled = valueProp !== void 0;
  const setValue = useEventCallback((nextValue, eventDetails) => {
    onValueChange == null ? void 0 : onValueChange(nextValue, eventDetails);
    if (eventDetails.isCanceled) {
      return;
    }
    setValueUnwrapped(nextValue);
  });
  useField({
    id,
    name,
    commitValidation,
    value,
    getValue: () => {
      var _a;
      return (_a = inputRef.current) == null ? void 0 : _a.value;
    },
    controlRef: inputRef
  });
  const element = useRenderElement("input", componentProps, {
    ref: forwardedRef,
    state,
    props: [{
      id,
      disabled,
      name,
      ref: inputRef,
      "aria-labelledby": labelId,
      ...isControlled ? {
        value
      } : {
        defaultValue
      },
      onChange(event) {
        const inputValue = event.currentTarget.value;
        setValue(inputValue, createBaseUIEventDetails("none", event.nativeEvent));
        setDirty(inputValue !== validityData.initialValue);
        setFilled(inputValue !== "");
      },
      onFocus() {
        setFocused(true);
      },
      onBlur(event) {
        setTouched(true);
        setFocused(false);
        if (validationMode === "onBlur") {
          commitValidation(event.currentTarget.value);
        }
      },
      onKeyDown(event) {
        if (event.currentTarget.tagName === "INPUT" && event.key === "Enter") {
          setTouched(true);
          commitValidation(event.currentTarget.value);
        }
      }
    }, getValidationProps(), getInputValidationProps(), elementProps],
    customStyleHookMapping: fieldValidityMapping
  });
  return element;
});
if (true)
  FieldControl.displayName = "FieldControl";

// node_modules/@base-ui-components/react/esm/field/validity/FieldValidity.js
var React14 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var FieldValidity = function FieldValidity2(props) {
  const {
    children
  } = props;
  const {
    validityData,
    invalid
  } = useFieldRootContext(false);
  const fieldValidityState = React14.useMemo(() => {
    const combinedFieldValidityData = getCombinedFieldValidityData(validityData, invalid);
    return {
      ...combinedFieldValidityData,
      validity: combinedFieldValidityData.state
    };
  }, [validityData, invalid]);
  return (0, import_jsx_runtime2.jsx)(React14.Fragment, {
    children: children(fieldValidityState)
  });
};
if (true)
  FieldValidity.displayName = "FieldValidity";
export {
  index_parts_exports as Field
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@base-ui-components_react_field.js.map
