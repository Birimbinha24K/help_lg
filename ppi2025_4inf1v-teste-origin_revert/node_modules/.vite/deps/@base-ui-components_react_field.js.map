{
  "version": 3,
  "sources": ["../../@base-ui-components/react/esm/field/index.parts.js", "../../@base-ui-components/react/esm/field/root/FieldRoot.js", "../../@base-ui-components/react/esm/field/root/FieldRootContext.js", "../../@base-ui-components/react/esm/field/control/FieldControlDataAttributes.js", "../../@base-ui-components/react/esm/field/utils/constants.js", "../../@base-ui-components/react/esm/fieldset/root/FieldsetRootContext.js", "../../@base-ui-components/react/esm/field/label/FieldLabel.js", "../../@base-ui-components/utils/esm/useIsoLayoutEffect.js", "../../@base-ui-components/utils/esm/detectBrowser.js", "../../@base-ui-components/react/esm/floating-ui-react/utils/element.js", "../../@floating-ui/utils/dist/floating-ui.utils.mjs", "../../tabbable/src/index.js", "../../@base-ui-components/utils/esm/useId.js", "../../@base-ui-components/utils/esm/safeReact.js", "../../@base-ui-components/react/esm/utils/useBaseUiId.js", "../../@base-ui-components/react/esm/field/error/FieldError.js", "../../@base-ui-components/react/esm/field/description/FieldDescription.js", "../../@base-ui-components/react/esm/field/control/FieldControl.js", "../../@base-ui-components/utils/esm/useControlled.js", "../../@base-ui-components/react/esm/field/useField.js", "../../@base-ui-components/utils/esm/useLatestRef.js", "../../@base-ui-components/react/esm/field/utils/getCombinedFieldValidityData.js", "../../@base-ui-components/react/esm/field/control/useFieldControlValidation.js", "../../@base-ui-components/utils/esm/useOnMount.js", "../../@base-ui-components/utils/esm/useTimeout.js", "../../@base-ui-components/react/esm/utils/createBaseUIEventDetails.js", "../../@base-ui-components/react/esm/field/validity/FieldValidity.js"],
  "sourcesContent": ["export { FieldRoot as Root } from \"./root/FieldRoot.js\";\nexport { FieldLabel as Label } from \"./label/FieldLabel.js\";\nexport { FieldError as Error } from \"./error/FieldError.js\";\nexport { FieldDescription as Description } from \"./description/FieldDescription.js\";\nexport { FieldControl as Control } from \"./control/FieldControl.js\";\nexport { FieldValidity as Validity } from \"./validity/FieldValidity.js\";", "'use client';\n\nimport * as React from 'react';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { FieldRootContext } from \"./FieldRootContext.js\";\nimport { DEFAULT_VALIDITY_STATE, fieldValidityMapping } from \"../utils/constants.js\";\nimport { useFieldsetRootContext } from \"../../fieldset/root/FieldsetRootContext.js\";\nimport { useFormContext } from \"../../form/FormContext.js\";\nimport { useRenderElement } from \"../../utils/useRenderElement.js\";\n\n/**\n * Groups all parts of the field.\n * Renders a `<div>` element.\n *\n * Documentation: [Base UI Field](https://base-ui.com/react/components/field)\n */\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const FieldRoot = /*#__PURE__*/React.forwardRef(function FieldRoot(componentProps, forwardedRef) {\n  const {\n    render,\n    className,\n    validate: validateProp,\n    validationDebounceTime = 0,\n    validationMode = 'onBlur',\n    name,\n    disabled: disabledProp = false,\n    invalid: invalidProp,\n    ...elementProps\n  } = componentProps;\n  const {\n    disabled: disabledFieldset\n  } = useFieldsetRootContext();\n  const {\n    errors\n  } = useFormContext();\n  const validate = useEventCallback(validateProp || (() => null));\n  const disabled = disabledFieldset || disabledProp;\n  const [controlId, setControlId] = React.useState(undefined);\n  const [labelId, setLabelId] = React.useState(undefined);\n  const [messageIds, setMessageIds] = React.useState([]);\n  const [touched, setTouched] = React.useState(false);\n  const [dirty, setDirtyUnwrapped] = React.useState(false);\n  const [filled, setFilled] = React.useState(false);\n  const [focused, setFocused] = React.useState(false);\n  const markedDirtyRef = React.useRef(false);\n  const setDirty = React.useCallback(value => {\n    if (value) {\n      markedDirtyRef.current = true;\n    }\n    setDirtyUnwrapped(value);\n  }, []);\n  const invalid = Boolean(invalidProp || name && {}.hasOwnProperty.call(errors, name) && errors[name] !== undefined);\n  const [validityData, setValidityData] = React.useState({\n    state: DEFAULT_VALIDITY_STATE,\n    error: '',\n    errors: [],\n    value: null,\n    initialValue: null\n  });\n  const valid = !invalid && validityData.state.valid;\n  const state = React.useMemo(() => ({\n    disabled,\n    touched,\n    dirty,\n    valid,\n    filled,\n    focused\n  }), [disabled, touched, dirty, valid, filled, focused]);\n  const contextValue = React.useMemo(() => ({\n    invalid,\n    controlId,\n    setControlId,\n    labelId,\n    setLabelId,\n    messageIds,\n    setMessageIds,\n    name,\n    validityData,\n    setValidityData,\n    disabled,\n    touched,\n    setTouched,\n    dirty,\n    setDirty,\n    filled,\n    setFilled,\n    focused,\n    setFocused,\n    validate,\n    validationMode,\n    validationDebounceTime,\n    state,\n    markedDirtyRef\n  }), [invalid, controlId, labelId, messageIds, name, validityData, disabled, touched, dirty, setDirty, filled, setFilled, focused, setFocused, validate, validationMode, validationDebounceTime, state]);\n  const element = useRenderElement('div', componentProps, {\n    ref: forwardedRef,\n    state,\n    props: elementProps,\n    customStyleHookMapping: fieldValidityMapping\n  });\n  return /*#__PURE__*/_jsx(FieldRootContext.Provider, {\n    value: contextValue,\n    children: element\n  });\n});\nif (process.env.NODE_ENV !== \"production\") FieldRoot.displayName = \"FieldRoot\";", "'use client';\n\nimport * as React from 'react';\nimport { NOOP } from \"../../utils/noop.js\";\nimport { DEFAULT_VALIDITY_STATE } from \"../utils/constants.js\";\nexport const FieldRootContext = /*#__PURE__*/React.createContext({\n  invalid: undefined,\n  controlId: undefined,\n  setControlId: NOOP,\n  labelId: undefined,\n  setLabelId: NOOP,\n  messageIds: [],\n  setMessageIds: NOOP,\n  name: undefined,\n  validityData: {\n    state: DEFAULT_VALIDITY_STATE,\n    errors: [],\n    error: '',\n    value: '',\n    initialValue: null\n  },\n  setValidityData: NOOP,\n  disabled: undefined,\n  touched: false,\n  setTouched: NOOP,\n  dirty: false,\n  setDirty: NOOP,\n  filled: false,\n  setFilled: NOOP,\n  focused: false,\n  setFocused: NOOP,\n  validate: () => null,\n  validationMode: 'onBlur',\n  validationDebounceTime: 0,\n  state: {\n    disabled: false,\n    valid: null,\n    touched: false,\n    dirty: false,\n    filled: false,\n    focused: false\n  },\n  markedDirtyRef: {\n    current: false\n  }\n});\nif (process.env.NODE_ENV !== \"production\") FieldRootContext.displayName = \"FieldRootContext\";\nexport function useFieldRootContext(optional = true) {\n  const context = React.useContext(FieldRootContext);\n  if (context.setControlId === NOOP && !optional) {\n    throw new Error('Base UI: FieldRootContext is missing. Field parts must be placed within <Field.Root>.');\n  }\n  return context;\n}", "export let FieldControlDataAttributes = /*#__PURE__*/function (FieldControlDataAttributes) {\n  /**\n   * Present when the field is disabled.\n   */\n  FieldControlDataAttributes[\"disabled\"] = \"data-disabled\";\n  /**\n   * Present when the field is in valid state.\n   */\n  FieldControlDataAttributes[\"valid\"] = \"data-valid\";\n  /**\n   * Present when the field is in invalid state.\n   */\n  FieldControlDataAttributes[\"invalid\"] = \"data-invalid\";\n  /**\n   * Present when the field has been touched.\n   */\n  FieldControlDataAttributes[\"touched\"] = \"data-touched\";\n  /**\n   * Present when the field's value has changed.\n   */\n  FieldControlDataAttributes[\"dirty\"] = \"data-dirty\";\n  /**\n   * Present when the field is filled.\n   */\n  FieldControlDataAttributes[\"filled\"] = \"data-filled\";\n  /**\n   * Present when the field control is focused.\n   */\n  FieldControlDataAttributes[\"focused\"] = \"data-focused\";\n  return FieldControlDataAttributes;\n}({});", "import { FieldControlDataAttributes } from \"../control/FieldControlDataAttributes.js\";\nexport const DEFAULT_VALIDITY_STATE = {\n  badInput: false,\n  customError: false,\n  patternMismatch: false,\n  rangeOverflow: false,\n  rangeUnderflow: false,\n  stepMismatch: false,\n  tooLong: false,\n  tooShort: false,\n  typeMismatch: false,\n  valid: null,\n  valueMissing: false\n};\nexport const fieldValidityMapping = {\n  valid(value) {\n    if (value === null) {\n      return null;\n    }\n    if (value) {\n      return {\n        [FieldControlDataAttributes.valid]: ''\n      };\n    }\n    return {\n      [FieldControlDataAttributes.invalid]: ''\n    };\n  }\n};", "'use client';\n\nimport * as React from 'react';\nexport const FieldsetRootContext = /*#__PURE__*/React.createContext({\n  legendId: undefined,\n  setLegendId: () => {},\n  disabled: undefined\n});\nif (process.env.NODE_ENV !== \"production\") FieldsetRootContext.displayName = \"FieldsetRootContext\";\nexport function useFieldsetRootContext() {\n  return React.useContext(FieldsetRootContext);\n}", "'use client';\n\nimport * as React from 'react';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { getTarget } from \"../../floating-ui-react/utils.js\";\nimport { useFieldRootContext } from \"../root/FieldRootContext.js\";\nimport { fieldValidityMapping } from \"../utils/constants.js\";\nimport { useBaseUiId } from \"../../utils/useBaseUiId.js\";\nimport { useRenderElement } from \"../../utils/useRenderElement.js\";\n\n/**\n * An accessible label that is automatically associated with the field control.\n * Renders a `<label>` element.\n *\n * Documentation: [Base UI Field](https://base-ui.com/react/components/field)\n */\nexport const FieldLabel = /*#__PURE__*/React.forwardRef(function FieldLabel(componentProps, forwardedRef) {\n  const {\n    render,\n    className,\n    id: idProp,\n    ...elementProps\n  } = componentProps;\n  const {\n    labelId,\n    setLabelId,\n    state,\n    controlId\n  } = useFieldRootContext(false);\n  const id = useBaseUiId(idProp);\n  const htmlFor = controlId ?? undefined;\n  useIsoLayoutEffect(() => {\n    if (controlId != null || idProp) {\n      setLabelId(id);\n    }\n    return () => {\n      setLabelId(undefined);\n    };\n  }, [controlId, id, idProp, setLabelId]);\n  const element = useRenderElement('label', componentProps, {\n    ref: forwardedRef,\n    state,\n    props: [{\n      id: labelId,\n      htmlFor,\n      onMouseDown(event) {\n        const target = getTarget(event.nativeEvent);\n        if (target?.closest('button,input,select,textarea')) {\n          return;\n        }\n\n        // Prevent text selection when double clicking label.\n        if (!event.defaultPrevented && event.detail > 1) {\n          event.preventDefault();\n        }\n      }\n    }, elementProps],\n    customStyleHookMapping: fieldValidityMapping\n  });\n  return element;\n});\nif (process.env.NODE_ENV !== \"production\") FieldLabel.displayName = \"FieldLabel\";", "'use client';\n\nimport * as React from 'react';\nconst noop = () => {};\nexport const useIsoLayoutEffect = typeof document !== 'undefined' ? React.useLayoutEffect : noop;", "const hasNavigator = typeof navigator !== 'undefined';\nconst nav = getNavigatorData();\nconst platform = getPlatform();\nconst userAgent = getUserAgent();\nexport const isWebKit = typeof CSS === 'undefined' || !CSS.supports ? false : CSS.supports('-webkit-backdrop-filter:none');\nexport const isIOS =\n// iPads can claim to be MacIntel\nnav.platform === 'MacIntel' && nav.maxTouchPoints > 1 ? true : /iP(hone|ad|od)|iOS/.test(nav.platform);\nexport const isFirefox = hasNavigator && /firefox/i.test(userAgent);\nexport const isSafari = hasNavigator && /apple/i.test(navigator.vendor);\nexport const isAndroid = hasNavigator && /android/i.test(platform) || /android/i.test(userAgent);\nexport const isMac = hasNavigator && platform.toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\nexport const isJSDOM = userAgent.includes('jsdom/');\n\n// Avoid Chrome DevTools blue warning.\nfunction getNavigatorData() {\n  if (!hasNavigator) {\n    return {\n      platform: '',\n      maxTouchPoints: -1\n    };\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData?.platform) {\n    return {\n      platform: uaData.platform,\n      maxTouchPoints: navigator.maxTouchPoints\n    };\n  }\n  return {\n    platform: navigator.platform ?? '',\n    maxTouchPoints: navigator.maxTouchPoints ?? -1\n  };\n}\nfunction getUserAgent() {\n  if (!hasNavigator) {\n    return '';\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(({\n      brand,\n      version\n    }) => `${brand}/${version}`).join(' ');\n  }\n  return navigator.userAgent;\n}\nfunction getPlatform() {\n  if (!hasNavigator) {\n    return '';\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData?.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform ?? '';\n}", "import { isHTMLElement, isShadowRoot } from '@floating-ui/utils/dom';\nimport { isJSDOM } from '@base-ui-components/utils/detectBrowser';\nimport { FOCUSABLE_ATTRIBUTE, TYPEABLE_SELECTOR } from \"./constants.js\";\nexport function activeElement(doc) {\n  let element = doc.activeElement;\n  while (element?.shadowRoot?.activeElement != null) {\n    element = element.shadowRoot.activeElement;\n  }\n  return element;\n}\nexport function contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode?.();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\nexport function getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nexport function isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const eventAgain = event;\n  return eventAgain.target != null && node.contains(eventAgain.target);\n}\nexport function isRootElement(element) {\n  return element.matches('html,body');\n}\nexport function getDocument(node) {\n  return node?.ownerDocument || document;\n}\nexport function isTypeableElement(element) {\n  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);\n}\nexport function isTypeableCombobox(element) {\n  if (!element) {\n    return false;\n  }\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\nexport function matchesFocusVisible(element) {\n  // We don't want to block focus from working with `visibleOnly`\n  // (JSDOM doesn't match `:focus-visible` when the element has `:focus`)\n  if (!element || isJSDOM) {\n    return true;\n  }\n  try {\n    return element.matches(':focus-visible');\n  } catch (_e) {\n    return true;\n  }\n}\nexport function getFloatingFocusElement(floatingElement) {\n  if (!floatingElement) {\n    return null;\n  }\n  // Try to find the element that has `{...getFloatingProps()}` spread on it.\n  // This indicates the floating element is acting as a positioning wrapper, and\n  // so focus should be managed on the child element with the event handlers and\n  // aria props.\n  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(`[${FOCUSABLE_ATTRIBUTE}]`) || floatingElement;\n}", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nconst yAxisSides = /*#__PURE__*/new Set(['top', 'bottom']);\nfunction getSideAxis(placement) {\n  return yAxisSides.has(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nconst lrPlacement = ['left', 'right'];\nconst rlPlacement = ['right', 'left'];\nconst tbPlacement = ['top', 'bottom'];\nconst btPlacement = ['bottom', 'top'];\nfunction getSideList(side, isStart, rtl) {\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rlPlacement : lrPlacement;\n      return isStart ? lrPlacement : rlPlacement;\n    case 'left':\n    case 'right':\n      return isStart ? tbPlacement : btPlacement;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nconst candidateSelectors = [\n  'input:not([inert])',\n  'select:not([inert])',\n  'textarea:not([inert])',\n  'a[href]:not([inert])',\n  'button:not([inert])',\n  '[tabindex]:not(slot):not([inert])',\n  'audio[controls]:not([inert])',\n  'video[controls]:not([inert])',\n  '[contenteditable]:not([contenteditable=\"false\"]):not([inert])',\n  'details>summary:first-of-type:not([inert])',\n  'details:not([inert])',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst NoElement = typeof Element === 'undefined';\n\nconst matches = NoElement\n  ? function () {}\n  : Element.prototype.matches ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.webkitMatchesSelector;\n\nconst getRootNode =\n  !NoElement && Element.prototype.getRootNode\n    ? (element) => element?.getRootNode?.()\n    : (element) => element?.ownerDocument;\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nconst isInert = function (node, lookUp = true) {\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  const inertAtt = node?.getAttribute?.('inert');\n  const inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  const result = inert || (lookUp && node && isInert(node.parentNode)); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nconst isContentEditable = function (node) {\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  const attValue = node?.getAttribute?.('contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nconst getCandidates = function (el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nconst getCandidatesIteratively = function (\n  elements,\n  includeContainer,\n  options\n) {\n  const candidates = [];\n  const elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    const element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      const assigned = element.assignedElements();\n      const content = assigned.length ? assigned : element.children;\n      const nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push(...nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates,\n        });\n      }\n    } else {\n      // check candidate element\n      const validCandidate = matches.call(element, candidateSelector);\n      if (\n        validCandidate &&\n        options.filter(element) &&\n        (includeContainer || !elements.includes(element))\n      ) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      const shadowRoot =\n        element.shadowRoot ||\n        // check for an undisclosed shadow\n        (typeof options.getShadowRoot === 'function' &&\n          options.getShadowRoot(element));\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      const validShadowRoot =\n        !isInert(shadowRoot, false) &&\n        (!options.shadowRootFilter || options.shadowRootFilter(element));\n\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        const nestedCandidates = getCandidatesIteratively(\n          shadowRoot === true ? element.children : shadowRoot.children,\n          true,\n          options\n        );\n\n        if (options.flatten) {\n          candidates.push(...nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: nestedCandidates,\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift(...element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nconst hasTabIndex = function (node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nconst getTabIndex = function (node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if (\n      (/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) ||\n        isContentEditable(node)) &&\n      !hasTabIndex(node)\n    ) {\n      return 0;\n    }\n  }\n\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nconst getSortOrderTabIndex = function (node, isScope) {\n  const tabIndex = getTabIndex(node);\n\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n\n  return tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || getRootNode(node);\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nconst isNodeAttached = function (node) {\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  let nodeRoot = node && getRootNode(node);\n  let nodeRootHost = nodeRoot?.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  let attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    attached = !!(\n      nodeRootHost?.ownerDocument?.contains(nodeRootHost) ||\n      node?.ownerDocument?.contains(node)\n    );\n\n    while (!attached && nodeRootHost) {\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = nodeRoot?.host;\n      attached = !!nodeRootHost?.ownerDocument?.contains(nodeRootHost);\n    }\n  }\n\n  return attached;\n};\n\nconst isZeroArea = function (node) {\n  const { width, height } = node.getBoundingClientRect();\n  return width === 0 && height === 0;\n};\nconst isHidden = function (node, { displayCheck, getShadowRoot }) {\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (\n    !displayCheck ||\n    displayCheck === 'full' ||\n    displayCheck === 'legacy-full'\n  ) {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      const originalNode = node;\n      while (node) {\n        const parentElement = node.parentElement;\n        const rootNode = getRootNode(node);\n        if (\n          parentElement &&\n          !parentElement.shadowRoot &&\n          getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    let parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *')\n              ? true\n              : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    // we must do an inert look up to filter out any elements inside an inert ancestor\n    //  because we're limited in the type of selectors we can use in JSDom (see related\n    //  note related to `candidateSelectors`)\n    isInert(node) ||\n    isHiddenInput(node) ||\n    isHidden(node, options) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    isNonTabbableRadio(node) ||\n    getTabIndex(node) < 0 ||\n    !isNodeMatchingSelectorFocusable(options, node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isValidShadowRootTabbable = function (shadowHostNode) {\n  const tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nconst sortByOrder = function (candidates) {\n  const regularTabbables = [];\n  const orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    const isScope = !!item.scopeParent;\n    const element = isScope ? item.scopeParent : item;\n    const candidateTabindex = getSortOrderTabIndex(element, isScope);\n    const elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope\n        ? regularTabbables.push(...elements)\n        : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements,\n      });\n    }\n  });\n\n  return orderedTabbables\n    .sort(sortOrderedTabbables)\n    .reduce((acc, sortable) => {\n      sortable.isScope\n        ? acc.push(...sortable.content)\n        : acc.push(sortable.content);\n      return acc;\n    }, [])\n    .concat(regularTabbables);\n};\n\nconst tabbable = function (container, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively(\n      [container],\n      options.includeContainer,\n      {\n        filter: isNodeMatchingSelectorTabbable.bind(null, options),\n        flatten: false,\n        getShadowRoot: options.getShadowRoot,\n        shadowRootFilter: isValidShadowRootTabbable,\n      }\n    );\n  } else {\n    candidates = getCandidates(\n      container,\n      options.includeContainer,\n      isNodeMatchingSelectorTabbable.bind(null, options)\n    );\n  }\n  return sortByOrder(candidates);\n};\n\nconst focusable = function (container, options) {\n  options = options || {};\n\n  let candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively(\n      [container],\n      options.includeContainer,\n      {\n        filter: isNodeMatchingSelectorFocusable.bind(null, options),\n        flatten: true,\n        getShadowRoot: options.getShadowRoot,\n      }\n    );\n  } else {\n    candidates = getCandidates(\n      container,\n      options.includeContainer,\n      isNodeMatchingSelectorFocusable.bind(null, options)\n    );\n  }\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable, getTabIndex };\n", "'use client';\n\nimport * as React from 'react';\nimport { SafeReact } from \"./safeReact.js\";\nlet globalId = 0;\n\n// TODO React 17: Remove `useGlobalId` once React 17 support is removed\nfunction useGlobalId(idOverride, prefix = 'mui') {\n  const [defaultId, setDefaultId] = React.useState(idOverride);\n  const id = idOverride || defaultId;\n  React.useEffect(() => {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the incrementing value for client-side rendering only.\n      // We can't use it server-side.\n      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem\n      globalId += 1;\n      setDefaultId(`${prefix}-${globalId}`);\n    }\n  }, [defaultId, prefix]);\n  return id;\n}\nconst maybeReactUseId = SafeReact.useId;\n\n/**\n *\n * @example <div id={useId()} />\n * @param idOverride\n * @returns {string}\n */\nexport function useId(idOverride, prefix) {\n  // React.useId() is only available from React 17.0.0.\n  if (maybeReactUseId !== undefined) {\n    const reactId = maybeReactUseId();\n    return idOverride ?? (prefix ? `${prefix}-${reactId}` : reactId);\n  }\n\n  // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler\n  // eslint-disable-next-line react-hooks/rules-of-hooks -- `React.useId` is invariant at runtime.\n  return useGlobalId(idOverride, prefix);\n}", "import * as React from 'react';\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nexport const SafeReact = {\n  ...React\n};", "'use client';\n\nimport { useId } from '@base-ui-components/utils/useId';\n\n/**\n * Wraps `useId` and prefixes generated `id`s with `base-ui-`\n * @param {string | undefined} idOverride overrides the generated id when provided\n * @returns {string | undefined}\n */\nexport function useBaseUiId(idOverride) {\n  return useId(idOverride, 'base-ui');\n}", "'use client';\n\nimport * as React from 'react';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useFieldRootContext } from \"../root/FieldRootContext.js\";\nimport { fieldValidityMapping } from \"../utils/constants.js\";\nimport { useFormContext } from \"../../form/FormContext.js\";\nimport { useRenderElement } from \"../../utils/useRenderElement.js\";\nimport { useBaseUiId } from \"../../utils/useBaseUiId.js\";\n\n/**\n * An error message displayed if the field control fails validation.\n * Renders a `<div>` element.\n *\n * Documentation: [Base UI Field](https://base-ui.com/react/components/field)\n */\nexport const FieldError = /*#__PURE__*/React.forwardRef(function FieldError(componentProps, forwardedRef) {\n  const {\n    render,\n    id: idProp,\n    className,\n    match,\n    ...elementProps\n  } = componentProps;\n  const id = useBaseUiId(idProp);\n  const {\n    validityData,\n    state,\n    name,\n    setMessageIds\n  } = useFieldRootContext(false);\n  const {\n    errors\n  } = useFormContext();\n  const formError = name ? errors[name] : null;\n  let rendered = false;\n  if (formError || match === true) {\n    rendered = true;\n  } else if (match) {\n    rendered = Boolean(validityData.state[match]);\n  } else {\n    rendered = validityData.state.valid === false;\n  }\n  useIsoLayoutEffect(() => {\n    if (!rendered || !id) {\n      return undefined;\n    }\n    setMessageIds(v => v.concat(id));\n    return () => {\n      setMessageIds(v => v.filter(item => item !== id));\n    };\n  }, [rendered, id, setMessageIds]);\n  const element = useRenderElement('div', componentProps, {\n    ref: forwardedRef,\n    state,\n    props: [{\n      id,\n      children: formError || (validityData.errors.length > 1 ? /*#__PURE__*/React.createElement('ul', {}, validityData.errors.map(message => /*#__PURE__*/React.createElement('li', {\n        key: message\n      }, message))) : validityData.error)\n    }, elementProps],\n    customStyleHookMapping: fieldValidityMapping\n  });\n  if (!rendered) {\n    return null;\n  }\n  return element;\n});\nif (process.env.NODE_ENV !== \"production\") FieldError.displayName = \"FieldError\";", "'use client';\n\nimport * as React from 'react';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useFieldRootContext } from \"../root/FieldRootContext.js\";\nimport { fieldValidityMapping } from \"../utils/constants.js\";\nimport { useBaseUiId } from \"../../utils/useBaseUiId.js\";\nimport { useRenderElement } from \"../../utils/useRenderElement.js\";\n\n/**\n * A paragraph with additional information about the field.\n * Renders a `<p>` element.\n *\n * Documentation: [Base UI Field](https://base-ui.com/react/components/field)\n */\nexport const FieldDescription = /*#__PURE__*/React.forwardRef(function FieldDescription(componentProps, forwardedRef) {\n  const {\n    render,\n    id: idProp,\n    className,\n    ...elementProps\n  } = componentProps;\n  const {\n    state\n  } = useFieldRootContext(false);\n  const id = useBaseUiId(idProp);\n  const {\n    setMessageIds\n  } = useFieldRootContext();\n  useIsoLayoutEffect(() => {\n    if (!id) {\n      return undefined;\n    }\n    setMessageIds(v => v.concat(id));\n    return () => {\n      setMessageIds(v => v.filter(item => item !== id));\n    };\n  }, [id, setMessageIds]);\n  const element = useRenderElement('p', componentProps, {\n    ref: forwardedRef,\n    state,\n    props: [{\n      id\n    }, elementProps],\n    customStyleHookMapping: fieldValidityMapping\n  });\n  return element;\n});\nif (process.env.NODE_ENV !== \"production\") FieldDescription.displayName = \"FieldDescription\";", "'use client';\n\nimport * as React from 'react';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { useControlled } from '@base-ui-components/utils/useControlled';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useFieldRootContext } from \"../root/FieldRootContext.js\";\nimport { fieldValidityMapping } from \"../utils/constants.js\";\nimport { useRenderElement } from \"../../utils/useRenderElement.js\";\nimport { useField } from \"../useField.js\";\nimport { useBaseUiId } from \"../../utils/useBaseUiId.js\";\nimport { useFieldControlValidation } from \"./useFieldControlValidation.js\";\nimport { createBaseUIEventDetails } from \"../../utils/createBaseUIEventDetails.js\";\n\n/**\n * The form control to label and validate.\n * Renders an `<input>` element.\n *\n * You can omit this part and use any Base UI input component instead. For example,\n * [Input](https://base-ui.com/react/components/input), [Checkbox](https://base-ui.com/react/components/checkbox),\n * or [Select](https://base-ui.com/react/components/select), among others, will work with Field out of the box.\n *\n * Documentation: [Base UI Field](https://base-ui.com/react/components/field)\n */\nexport const FieldControl = /*#__PURE__*/React.forwardRef(function FieldControl(componentProps, forwardedRef) {\n  const {\n    render,\n    className,\n    id: idProp,\n    name: nameProp,\n    value: valueProp,\n    disabled: disabledProp = false,\n    onValueChange,\n    defaultValue,\n    ...elementProps\n  } = componentProps;\n  const {\n    state: fieldState,\n    name: fieldName,\n    disabled: fieldDisabled\n  } = useFieldRootContext();\n  const disabled = fieldDisabled || disabledProp;\n  const name = fieldName ?? nameProp;\n  const state = React.useMemo(() => ({\n    ...fieldState,\n    disabled\n  }), [fieldState, disabled]);\n  const {\n    setControlId,\n    labelId,\n    setTouched,\n    setDirty,\n    validityData,\n    setFocused,\n    setFilled,\n    validationMode\n  } = useFieldRootContext();\n  const {\n    getValidationProps,\n    getInputValidationProps,\n    commitValidation,\n    inputRef\n  } = useFieldControlValidation();\n  const id = useBaseUiId(idProp);\n  useIsoLayoutEffect(() => {\n    setControlId(id);\n    return () => {\n      setControlId(undefined);\n    };\n  }, [id, setControlId]);\n  useIsoLayoutEffect(() => {\n    const hasExternalValue = valueProp != null;\n    if (inputRef.current?.value || hasExternalValue && valueProp !== '') {\n      setFilled(true);\n    } else if (hasExternalValue && valueProp === '') {\n      setFilled(false);\n    }\n  }, [inputRef, setFilled, valueProp]);\n  const [value, setValueUnwrapped] = useControlled({\n    controlled: valueProp,\n    default: defaultValue,\n    name: 'FieldControl',\n    state: 'value'\n  });\n  const isControlled = valueProp !== undefined;\n  const setValue = useEventCallback((nextValue, eventDetails) => {\n    onValueChange?.(nextValue, eventDetails);\n    if (eventDetails.isCanceled) {\n      return;\n    }\n    setValueUnwrapped(nextValue);\n  });\n  useField({\n    id,\n    name,\n    commitValidation,\n    value,\n    getValue: () => inputRef.current?.value,\n    controlRef: inputRef\n  });\n  const element = useRenderElement('input', componentProps, {\n    ref: forwardedRef,\n    state,\n    props: [{\n      id,\n      disabled,\n      name,\n      ref: inputRef,\n      'aria-labelledby': labelId,\n      ...(isControlled ? {\n        value\n      } : {\n        defaultValue\n      }),\n      onChange(event) {\n        const inputValue = event.currentTarget.value;\n        setValue(inputValue, createBaseUIEventDetails('none', event.nativeEvent));\n        setDirty(inputValue !== validityData.initialValue);\n        setFilled(inputValue !== '');\n      },\n      onFocus() {\n        setFocused(true);\n      },\n      onBlur(event) {\n        setTouched(true);\n        setFocused(false);\n        if (validationMode === 'onBlur') {\n          commitValidation(event.currentTarget.value);\n        }\n      },\n      onKeyDown(event) {\n        if (event.currentTarget.tagName === 'INPUT' && event.key === 'Enter') {\n          setTouched(true);\n          commitValidation(event.currentTarget.value);\n        }\n      }\n    }, getValidationProps(), getInputValidationProps(), elementProps],\n    customStyleHookMapping: fieldValidityMapping\n  });\n  return element;\n});\nif (process.env.NODE_ENV !== \"production\") FieldControl.displayName = \"FieldControl\";", "'use client';\n\n// TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- process.env never changes, dependency arrays are intentionally ignored\n/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */\nimport * as React from 'react';\nexport function useControlled({\n  controlled,\n  default: defaultProp,\n  name,\n  state = 'value'\n}) {\n  // isControlled is ignored in the hook dependency lists as it should never change.\n  const {\n    current: isControlled\n  } = React.useRef(controlled !== undefined);\n  const [valueState, setValue] = React.useState(defaultProp);\n  const value = isControlled ? controlled : valueState;\n  if (process.env.NODE_ENV !== 'production') {\n    React.useEffect(() => {\n      if (isControlled !== (controlled !== undefined)) {\n        console.error([`Base UI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', \"The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.\", 'More info: https://fb.me/react-controlled-components'].join('\\n'));\n      }\n    }, [state, name, controlled]);\n    const {\n      current: defaultValue\n    } = React.useRef(defaultProp);\n    React.useEffect(() => {\n      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is for more details.\n      if (!isControlled && JSON.stringify(defaultValue) !== JSON.stringify(defaultProp)) {\n        console.error([`Base UI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\\n'));\n      }\n    }, [JSON.stringify(defaultProp)]);\n  }\n  const setValueIfUncontrolled = React.useCallback(newValue => {\n    if (!isControlled) {\n      setValue(newValue);\n    }\n  }, []);\n  return [value, setValueIfUncontrolled];\n}", "import * as ReactDOM from 'react-dom';\nimport { useIsoLayoutEffect } from '@base-ui-components/utils/useIsoLayoutEffect';\nimport { useLatestRef } from '@base-ui-components/utils/useLatestRef';\nimport { getCombinedFieldValidityData } from \"./utils/getCombinedFieldValidityData.js\";\nimport { useFormContext } from \"../form/FormContext.js\";\nimport { useFieldRootContext } from \"./root/FieldRootContext.js\";\nexport function useField(params) {\n  const {\n    formRef\n  } = useFormContext();\n  const {\n    invalid,\n    markedDirtyRef,\n    validityData,\n    setValidityData\n  } = useFieldRootContext();\n  const {\n    enabled = true,\n    value,\n    id,\n    name,\n    controlRef,\n    commitValidation\n  } = params;\n  const getValueRef = useLatestRef(params.getValue);\n  useIsoLayoutEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    let initialValue = value;\n    if (initialValue === undefined) {\n      initialValue = getValueRef.current?.();\n    }\n    if (validityData.initialValue === null && initialValue !== validityData.initialValue) {\n      setValidityData(prev => ({\n        ...prev,\n        initialValue\n      }));\n    }\n  }, [enabled, setValidityData, value, validityData.initialValue, getValueRef]);\n  useIsoLayoutEffect(() => {\n    if (!enabled) {\n      return;\n    }\n    if (id) {\n      formRef.current.fields.set(id, {\n        controlRef,\n        validityData: getCombinedFieldValidityData(validityData, invalid),\n        validate() {\n          let nextValue = value;\n          if (nextValue === undefined) {\n            nextValue = getValueRef.current?.();\n          }\n          markedDirtyRef.current = true;\n          // Synchronously update the validity state so the submit event can be prevented.\n          ReactDOM.flushSync(() => commitValidation(nextValue));\n        },\n        getValueRef,\n        name\n      });\n    }\n  }, [commitValidation, controlRef, enabled, formRef, getValueRef, id, invalid, markedDirtyRef, name, validityData, value]);\n  useIsoLayoutEffect(() => {\n    const fields = formRef.current.fields;\n    return () => {\n      if (id) {\n        fields.delete(id);\n      }\n    };\n  }, [formRef, id]);\n}", "'use client';\n\nimport { useIsoLayoutEffect } from \"./useIsoLayoutEffect.js\";\nimport { useRefWithInit } from \"./useRefWithInit.js\";\nexport function useLatestRef(value) {\n  const latest = useRefWithInit(createLatestRef, value).current;\n  latest.next = value;\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useIsoLayoutEffect(latest.effect);\n  return latest;\n}\nfunction createLatestRef(value) {\n  const latest = {\n    current: value,\n    next: value,\n    effect: () => {\n      latest.current = latest.next;\n    }\n  };\n  return latest;\n}", "/**\n * Combines the field's client-side, stateful validity data with the external invalid state to\n * determine the field's true validity.\n */\nexport function getCombinedFieldValidityData(validityData, invalid) {\n  return {\n    ...validityData,\n    state: {\n      ...validityData.state,\n      valid: !invalid && validityData.state.valid\n    }\n  };\n}", "'use client';\n\nimport * as React from 'react';\nimport { useTimeout } from '@base-ui-components/utils/useTimeout';\nimport { useEventCallback } from '@base-ui-components/utils/useEventCallback';\nimport { useFieldRootContext } from \"../root/FieldRootContext.js\";\nimport { mergeProps } from \"../../merge-props/index.js\";\nimport { DEFAULT_VALIDITY_STATE } from \"../utils/constants.js\";\nimport { useFormContext } from \"../../form/FormContext.js\";\nimport { getCombinedFieldValidityData } from \"../utils/getCombinedFieldValidityData.js\";\nconst validityKeys = Object.keys(DEFAULT_VALIDITY_STATE);\nfunction isOnlyValueMissing(state) {\n  if (!state || state.valid || !state.valueMissing) {\n    return false;\n  }\n  let onlyValueMissing = false;\n  for (const key of validityKeys) {\n    if (key === 'valid') {\n      continue;\n    }\n    if (key === 'valueMissing') {\n      onlyValueMissing = state[key];\n    }\n    if (state[key]) {\n      onlyValueMissing = false;\n    }\n  }\n  return onlyValueMissing;\n}\nexport function useFieldControlValidation() {\n  const {\n    setValidityData,\n    validate,\n    messageIds,\n    validityData,\n    validationMode,\n    validationDebounceTime,\n    invalid,\n    markedDirtyRef,\n    controlId,\n    state,\n    name\n  } = useFieldRootContext();\n  const {\n    formRef,\n    clearErrors\n  } = useFormContext();\n  const timeout = useTimeout();\n  const inputRef = React.useRef(null);\n  const commitValidation = useEventCallback(async (value, revalidate = false) => {\n    const element = inputRef.current;\n    if (!element) {\n      return;\n    }\n    if (revalidate) {\n      if (state.valid !== false) {\n        return;\n      }\n      const currentNativeValidity = element.validity;\n      if (!currentNativeValidity.valueMissing) {\n        // The 'valueMissing' (required) condition has been resolved by the user typing.\n        // Temporarily mark the field as valid for this onChange event.\n        // Other native errors (e.g., typeMismatch) will be caught by full validation on blur or submit.\n        const nextValidityData = {\n          value,\n          state: {\n            ...DEFAULT_VALIDITY_STATE,\n            valid: true\n          },\n          error: '',\n          errors: [],\n          initialValue: validityData.initialValue\n        };\n        element.setCustomValidity('');\n        if (controlId) {\n          const currentFieldData = formRef.current.fields.get(controlId);\n          if (currentFieldData) {\n            formRef.current.fields.set(controlId, {\n              ...currentFieldData,\n              ...getCombinedFieldValidityData(nextValidityData, false) // invalid = false\n            });\n          }\n        }\n        setValidityData(nextValidityData);\n        return;\n      }\n\n      // Value is still missing, or other conditions apply.\n      // Let's use a representation of current validity for isOnlyValueMissing.\n      const currentNativeValidityObject = validityKeys.reduce((acc, key) => {\n        acc[key] = currentNativeValidity[key];\n        return acc;\n      }, {});\n\n      // If it's (still) natively invalid due to something other than just valueMissing,\n      // then bail from this revalidation on change to avoid \"scolding\" for other errors.\n      if (!currentNativeValidityObject.valid && !isOnlyValueMissing(currentNativeValidityObject)) {\n        return;\n      }\n\n      // If valueMissing is still true AND it's the only issue, or if the field is now natively valid,\n      // let it fall through to the main validation logic below.\n    }\n    function getState(el) {\n      const computedState = validityKeys.reduce((acc, key) => {\n        acc[key] = el.validity[key];\n        return acc;\n      }, {});\n      let hasOnlyValueMissingError = false;\n      for (const key of validityKeys) {\n        if (key === 'valid') {\n          continue;\n        }\n        if (key === 'valueMissing' && computedState[key]) {\n          hasOnlyValueMissingError = true;\n        } else if (computedState[key]) {\n          return computedState;\n        }\n      }\n\n      // Only make `valueMissing` mark the field invalid if it's been changed\n      // to reduce error noise.\n      if (hasOnlyValueMissingError && !markedDirtyRef.current) {\n        computedState.valid = true;\n        computedState.valueMissing = false;\n      }\n      return computedState;\n    }\n    timeout.clear();\n    let result = null;\n    let validationErrors = [];\n    const nextState = getState(element);\n    let defaultValidationMessage;\n    if (element.validationMessage) {\n      defaultValidationMessage = element.validationMessage;\n      validationErrors = [element.validationMessage];\n    } else {\n      const formValues = Array.from(formRef.current.fields.values()).reduce((acc, field) => {\n        if (field.name && field.getValueRef) {\n          acc[field.name] = field.getValueRef.current?.();\n        }\n        return acc;\n      }, {});\n      const resultOrPromise = validate(value, formValues);\n      if (typeof resultOrPromise === 'object' && resultOrPromise !== null && 'then' in resultOrPromise) {\n        result = await resultOrPromise;\n      } else {\n        result = resultOrPromise;\n      }\n      if (result !== null) {\n        nextState.valid = false;\n        nextState.customError = true;\n        if (Array.isArray(result)) {\n          validationErrors = result;\n          element.setCustomValidity(result.join('\\n'));\n        } else if (result) {\n          validationErrors = [result];\n          element.setCustomValidity(result);\n        }\n      }\n    }\n    const nextValidityData = {\n      value,\n      state: nextState,\n      error: defaultValidationMessage ?? (Array.isArray(result) ? result[0] : result ?? ''),\n      errors: validationErrors,\n      initialValue: validityData.initialValue\n    };\n    if (controlId) {\n      const currentFieldData = formRef.current.fields.get(controlId);\n      if (currentFieldData) {\n        formRef.current.fields.set(controlId, {\n          ...currentFieldData,\n          ...getCombinedFieldValidityData(nextValidityData, invalid)\n        });\n      }\n    }\n    setValidityData(nextValidityData);\n  });\n  const getValidationProps = React.useCallback((externalProps = {}) => mergeProps({\n    ...(messageIds.length && {\n      'aria-describedby': messageIds.join(' ')\n    }),\n    ...(state.valid === false && {\n      'aria-invalid': true\n    })\n  }, externalProps), [messageIds, state.valid]);\n  const getInputValidationProps = React.useCallback((externalProps = {}) => mergeProps({\n    onChange(event) {\n      // Workaround for https://github.com/facebook/react/issues/9023\n      if (event.nativeEvent.defaultPrevented) {\n        return;\n      }\n      clearErrors(name);\n      if (validationMode !== 'onChange') {\n        commitValidation(event.currentTarget.value, true);\n        return;\n      }\n      if (invalid) {\n        return;\n      }\n      const element = event.currentTarget;\n      if (element.value === '') {\n        // Ignore the debounce time for empty values.\n        commitValidation(element.value);\n        return;\n      }\n      timeout.clear();\n      if (validationDebounceTime) {\n        timeout.start(validationDebounceTime, () => {\n          commitValidation(element.value);\n        });\n      } else {\n        commitValidation(element.value);\n      }\n    }\n  }, getValidationProps(externalProps)), [getValidationProps, clearErrors, name, timeout, commitValidation, invalid, validationMode, validationDebounceTime]);\n  return React.useMemo(() => ({\n    getValidationProps,\n    getInputValidationProps,\n    inputRef,\n    commitValidation\n  }), [getValidationProps, getInputValidationProps, commitValidation]);\n}", "'use client';\n\nimport * as React from 'react';\nconst EMPTY = [];\n\n/**\n * A React.useEffect equivalent that runs once, when the component is mounted.\n */\nexport function useOnMount(fn) {\n  // TODO: uncomment once we enable eslint-plugin-react-compiler // eslint-disable-next-line react-compiler/react-compiler -- no need to put `fn` in the dependency array\n  /* eslint-disable react-hooks/exhaustive-deps */\n  React.useEffect(fn, EMPTY);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}", "'use client';\n\nimport { useRefWithInit } from \"./useRefWithInit.js\";\nimport { useOnMount } from \"./useOnMount.js\";\nconst EMPTY = 0;\nexport class Timeout {\n  static create() {\n    return new Timeout();\n  }\n  currentId = (() => EMPTY)();\n\n  /**\n   * Executes `fn` after `delay`, clearing any previously scheduled call.\n   */\n  start(delay, fn) {\n    this.clear();\n    this.currentId = setTimeout(() => {\n      this.currentId = EMPTY;\n      fn();\n    }, delay); /* Node.js types are enabled in development */\n  }\n  isStarted() {\n    return this.currentId !== EMPTY;\n  }\n  clear = () => {\n    if (this.currentId !== EMPTY) {\n      clearTimeout(this.currentId);\n      this.currentId = EMPTY;\n    }\n  };\n  disposeEffect = () => {\n    return this.clear;\n  };\n}\n\n/**\n * A `setTimeout` with automatic cleanup and guard.\n */\nexport function useTimeout() {\n  const timeout = useRefWithInit(Timeout.create).current;\n  useOnMount(timeout.disposeEffect);\n  return timeout;\n}", "/**\n * Maps an open-change `reason` string to the corresponding native event type.\n */\n\n/**\n * Details of custom events emitted by Base UI components.\n */\n\n/**\n * Creates a Base UI event details object with the given reason and utilities\n * for preventing Base UI's internal event handling.\n */\nexport function createBaseUIEventDetails(reason, event) {\n  let canceled = false;\n  let allowPropagation = false;\n  return {\n    reason,\n    event: event ?? new Event('base-ui'),\n    cancel() {\n      canceled = true;\n    },\n    allowPropagation() {\n      allowPropagation = true;\n    },\n    get isCanceled() {\n      return canceled;\n    },\n    get isPropagationAllowed() {\n      return allowPropagation;\n    }\n  };\n}", "'use client';\n\nimport * as React from 'react';\nimport { useFieldRootContext } from \"../root/FieldRootContext.js\";\nimport { getCombinedFieldValidityData } from \"../utils/getCombinedFieldValidityData.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n/**\n * Used to display a custom message based on the fields validity.\n * Requires `children` to be a function that accepts field validity state as an argument.\n *\n * Documentation: [Base UI Field](https://base-ui.com/react/components/field)\n */\nexport const FieldValidity = function FieldValidity(props) {\n  const {\n    children\n  } = props;\n  const {\n    validityData,\n    invalid\n  } = useFieldRootContext(false);\n  const fieldValidityState = React.useMemo(() => {\n    const combinedFieldValidityData = getCombinedFieldValidityData(validityData, invalid);\n    return {\n      ...combinedFieldValidityData,\n      validity: combinedFieldValidityData.state\n    };\n  }, [validityData, invalid]);\n  return /*#__PURE__*/_jsx(React.Fragment, {\n    children: children(fieldValidityState)\n  });\n};\nif (process.env.NODE_ENV !== \"production\") FieldValidity.displayName = \"FieldValidity\";"],
  "mappings": "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",
  "names": ["React", "FieldControlDataAttributes", "React", "FieldRoot", "_jsx", "React", "React", "candidateSelectors", "candidateSelector", "join", "NoElement", "Element", "matches", "prototype", "msMatchesSelector", "webkitMatchesSelector", "getRootNode", "element", "_element$getRootNode", "call", "ownerDocument", "focusableCandidateSelector", "candidateSelectors", "concat", "join", "React", "React", "FieldLabel", "React", "FieldError", "React", "FieldDescription", "React", "React", "React", "React", "EMPTY", "nextValidityData", "FieldControl", "React", "import_jsx_runtime", "FieldValidity", "_jsx"]
}
